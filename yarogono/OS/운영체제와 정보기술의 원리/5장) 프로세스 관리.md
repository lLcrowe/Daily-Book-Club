# 프로세스의 개념

실행 중인 프로그램(program in execution)을 뜻한다.

- 프로세스는 CPU를 획듣해 자신의 코드를 수행하기도 한다.
- 때로는 CPU를 반환하고 입출력 작업을 수행하기도 한다.

## 프로세스의 문맥(context)

프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 의미한다.

- 여러 프로세스가 시분할 시스템 환경에서 타이머 인터럽트에 의해 짧은 시간 동안 CPU를 사용한 후 빼앗겼다가 추후에 다시 CPU를 획득하는 식으로 CPU 관리가 이루어진다.
    - 여기서 보유 시기에 어느 정도 수행했는지 직전 수행 시점의 정확한 상태의 정보가 프로세스 문맥에 있다.

### 프로세스 문맥에 포함된 것들

- 프로세스 주소 공간(코드, 데이터, 스택 상태)을 비롯해 레지스터에 어떤 값을 가지고 있었는지
- 시스템 콜 등을 통해 커널에서 수행한 일의 상태
- 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등등

### 크게 3가지로 보는 프로세스 문맥

1. 하드웨어 문맥
    - CPU의 수행 상태를 나타내는 것으로 **프로그램 카운터값**과 **각종 레지스터에 저장하고 있는 값들**을 의미한다.
2. 프로세스의 주소 공간
    - 프로세스는 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.
    - 프로세스의 문맥을 결정짓는 중요한 요소 중 하나이다.
3. 커널상의 문맥

# 프로세스의 상태

---

프로세스의 상태는 **실행(running)**, **준비(ready)**, **봉쇄(blocked, wait, sleep)**의 세 가지로 구분할 수 있다. 이와 같이 프로세스의 상태를 구분하는 이유는 컴퓨터의 자원을 효율적으로 관리하기 위해서이다.

## 실행 상태

프로세스가 CPU를 보유하고, 기계어 명령을 실행하고 있는 상태를 가리킨다.

- 일반적인 컴퓨터 시스템 내에 CPU는 하나뿐이므로 컴퓨터 내에서 여러 프로세스가 동시에 수행된다고 해도 실제로 실행 상태에 있는 프로세스는 매 시점 하나뿐이다.

## 준비 상태

프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태를 가리킨다.

## 봉쇄 상태

CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태를 말한다.

- 프로세스가 요청한 입출력 작업이 진행 중인 경우를 들 수 있다.

## 이 밖에 프로세스 상태들

- 시작(new) 상태
    - 프로세스가 시작되어 그 프로세스를 위한 각종 잘구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태를 말한다.
- 완료(terminated) 상태
    - 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태를 말한다.

## 문맥교환(context switch)

실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

**문맥교환이 발생하는 경우**

- 타이머 인터럽트가 발생할 경우
- 실행 상태에 있던 프로세스가 입출력 요청 등으로 봉쇄 상태로 바뀌는 경우

## CPU 디스패치(dispatch)

준비 상태에 있던 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정

# 프로세스 제어블록(Process Control Block : PCB)

---

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 뜻한다.

![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/896d0c66-1cf5-4279-aaa4-ebd1fa5a6fc8/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230227T080600Z&X-Amz-Expires=86400&X-Amz-Signature=bd7a794e500ef3cb3c87b651ba3aad4831b29ce4785190b5e69c4cb8cc303d81&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22Untitled.png%22&x-id=GetObject)

## PCB의 요소

- 프로세스의 상태(process state)
    - CPU를 할당해도 되는지 여부를 결정하기 위해 필요
- 프로그램 카운터(program counter)의 값
    - 다음에 수행할 명령의 위치를 가리킨다.
- CPU 레지스터(CPU register)의 값
    - CPU 연산을 위해 현 시점에 레지스터에 어떤 값을 저장하고 있는지를 나타낸다.
- CPU 스케줄링 정보(CPU scheduling information)
    - CPU 스케줄을 위해 필요한 정보
- 메모리 관리 정보(memory management information)
    - 메모리 할다을 위해 필요한 정보
- 자원 사용 정보(accounting information)
    - 사용자에게 자원 사용 요금을 계산해 청구하는 등의 용도로 사용된다.
- 입출력 상태 정보(I/O status information)
    - 프로세스가 오픈한 파일 정보 등 프로세스의 입출력 관련 상태 정보를 나타낸다.

# 문맥교환(context switch)

---

하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.

문맥교환은 타이머 인터럽트가 발생하는 경우 외에 실행 중이던 프로세스가 입출력 요청이나 다른 조건을 충족하지 못해 CPU를 회수당하고 봉쇄 상태가 되는 경우에도 발생할 수 있다.

> 문맥 교환과 사용자 모드가 바뀌는 것은 다르다.
문맥 교환은 훨씬  많은 오버헤드(overhead)가 뒤따르게 된다.
>

- 타이머에 CPU 할당시간을 아주 작게 세팅해 프로세스 간 문맥교환이 빈번하게 발생하도록 하면 이에 드는 오버헤드가 상당히 커진다.
- 반대로 CPU 할당시간을 너무 크게 설정하면 시분할 시스템의 의미가 퇴색하게 되므로 적절한 CPU 할당 시간을 정해야 한다.

# 프로세스를 스케줄링하기 위한 큐

---

운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 준비 큐(ready queue)를 두고 준비 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.

- 준비 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.

CPU를 기다리는 프로세스를 줄 세우는 준비 큐 외에도 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐(device queue)를 둔다.

- 디스크에 입출력 서비스를 요청한 프로세스들은 디스크 입출력 큐(disk I/O queue)에 줄 서게 된다.
    - 디스크 컨트롤러는 디스크 입출력 큐에 줄 서 있는 순서대로 프로세스들의 입출력 작업을 수행한다.
    - 프로세스별 입출력 작업이 완료되면 디스크 컨트롤러가 CPU에 인터럽트를 발생시키게 되고, 그러면 인터럽트 처리루틴에 의해 디스크 입출력이 완료된 프로세스는 입출력 큐에서 빠져나와 CPU를 기다리는 준비큐에 줄 서게 된다.


## 데이터의 일관성과 프로세스 스케줄링

위 챕터에서 저자가 언급하는 큐들은 하드웨어 자원을 기다리는 프로세스들을 줄 세우기 위해 필요한 것이다. 이와 같은 큐는 **소프트웨어 자원을 기다리는 경우에도 필요**하다.

### 공유 데이터에 대한 접근 권한은 소프트웨어 자원으로 분류

- 어떠한 프로세스가 공유 데이터를 사용하는 중에 다른 프로세스가 같은 데이터를 접근하면 데이터에 대한 **일관성이 훼손**될 수 있다.
- 공유 데이터는 매 시점 하나의 프로세스만이 접근할 수 있도록 해야 한다.
    - 이때 접근하는 것이 반드시 CPU가 그 데이터를 사용하고 있음을 의미하는 것은 아니다.

> 공유 데이터라는 일종의 소프트웨어 자원을 앞서 접근 중인 프로세스가 다 사용하고 반납할 때까지는 다른 프로세스가 CPU를 할당받았다 하더라도 접근하지 말고 기다려야 하는 것이다.
>

## 정리

여러 프로세스가 공유 데이터에 동시에 접근하려고 할 경우 데이터를 기다리는 큐에 줄 서게 하여 현재 그 데이터를 사용하고 있는 프로세스가 데이터를 반납하기 전까지는 접근하지 못하게 하고, 반납할 경우 큐에 줄 서 있는 순서대로 데이터의 접근 권한을 주는 방법을 사용하게 된다.

각 프로세스가 CPU를 기다리는지, 입출력을 기다리는지 등의 정보를 커널이 총체적으로 관리한다.

# 스케줄러

---

어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.

## 스케줄러의 종류

- 장기 스케줄러(Long term scheduler)
    - 작업 스케줄러(job scheduler)라고도 부르며, 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할을 한다.
- 단기 스케줄러(short term scheduler)
    - CPU 스케줄러라고도 하며, 준비 상태의 프로세스 중에서 어떤 프로세스를 다음번에 실행 상태로 만들 것인지 결정한다.
    - 준비 큐에 있는 여러 프로세스들 중 어떠한 프로세스에게 CPU를 할당할 것인가를 단기 스케줄러가 결정하게 된다.
    - 시분할 시스템에서는 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.

### 단기 스케줄러 특성

- 밀리초 정도의 시간 단위로 매우 빈번하게 호출되기 때문에 수행 속도가 충분히 빨라야 한다.

### 장기 스케줄러 특성

- 수십 초 내지 수 분 단위로 가끔 호출되기 때문에 상대적으로 느린 것이 허용된다.
- 메모리에 동시에 올라가 있는 프로세스의 수(degree of multiprogramming)를 조절하는 역할을 한다.
    - 시작 상태의 프로세스에게 메모리 할당을 승인할지 여부를 장기 스케줄러가 결정하기 때문.

### 장기 스케줄러의 쇠퇴

- 과거에 자원이 매우 빈약했던 시절에 주로 사용되었다.
- 적은 양의 메모리를 많은 프로세스들에게 할당하면 프로세스당 메모리 보유량이 지나치게 적어져 시스템의 효율이 매우 떨어졌기 때문에 장기 스케줄러가 이를 조절하는 역할을 담당했기 때문이다.

현대의 시분할 시스템용 운영체제에서는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧바로 그 프로세스에 메모리를 할당해 준비 큐에 넣어주게 된다.

## 중기 스케줄러(medium term scheduling)

현대의 시분할 시스템용 운영체제에서는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다.

너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러이다.

### 스왑 아웃(swap out)

메모리에 올라와 있는 프로세스 중 일부를 선정해 이들로부터 메모리를 통째로 빼앗아 그 내용을 디스크의 스왑 영역에 저장하는 행위.

- 중기 스케줄러는 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할을 수행한다.

### 중지(suspened, stopped) 상태

중기 스케줄러의 등장으로 인해 추가된 상태로, 중지상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 당장 필요하지 않다. 따라서 중지 상태의 프로세스는 메모리를 통째로 빼앗기고 디스크로 스왑 아웃된다.

# 프로세스의 생성

---

운영체제가 프로세스 전부를 생성한다고 생각할 수 있지만 사실은 그렇지 않다.

시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그 다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다.

- 프로세스를 생성한 프로세스를 **부모 프로세스**라고 하고,
  새롭게 생성된 프로세스를 **자식 프로세스**라고 한다.
- 프로세스는 족보와 같은 계층을 형성하게 된다.
- 프로세스의 세계에서는 자식이 먼저 죽고, 이에대한 처리는 자식을 생성했던 부모 프로세스가 담당하는 방식으로 진행된다.

## 프로세스가 수행되는 모델

- 부모와 자식이 공존하며 수행되는 모델
    - 자식과 부모가 같이 CPU를 획득하기 위해 경쟁하는 관계
- 자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델
    - 자식 프로세스가 종료될 때까지 부모 프로세스는 아무 일도 하지 않고 봉쇄 상태에 머물러 있다가, 자식 프로세스가 종료되면 그때 부모 프로세스가 준비 상태가 되어 다시 CPU를 얻을 권한이 생기게 된다.

## 프로세스의 독자적인 주소 공간

- 부모 프로세스가 자식 프로세스를 생성하면 자식 프로세스는 부모 프로세스와는 별도의 주소 공간을 가지게 되는데, 처음 주소 공간을 생성할 때에는 부모 프로세스의 주소 공간 내용을 그대로 복사해서 생성한다.
- 자식 프로세스가 다른 프로그램을 생성하기 위해서는 생성된 주소 공간 위에 새로운 프로그램의 주소 공간 위에 새로운 프로그램의 주소 공간을 덮어씌워 실행하게 되는 것이다.

## 프로세스의 생성 절차

- 유닉스에서는 fork() 시스템 콜을 통해 새로운 프로세스를 생성할 수 있다.

### fork() 시스템 콜

자식 프로세스를 생성할 때 부모 프로세스의 내용을 그대로 복제 생성하게 된다.

즉, 프로세스 ID를 제외한 모든 정보(운영체제 커널 내의 정보와 주소 공간의 정보)를 그대로 복사하는 방법을 사용한다.

- fork()를 통해 생성된 자식 프로세스는 exec() 시스템 콜을 통해 새로운 프로그램으로 주소 공간을 덮어씌울 수 있다.

### exit() 함수

프로그램 개발자가 명시적으로 호출하지 않아도 프로그램이 종료되는 지점에 컴파일러가 자동으로 삽입해 프로세스의 종료 직전에 항상 호출된다.

### abort() 함수

비자발적 종료로 부모 프로세스가 자식 프로세스의 수행을 강제로 종료시키는 것이다.

**강제 종료가 발생하는 경우**

1. 자식 프로세스가 할당 자원의 한계치를 넘어서는 많은 양의 자원을 요구할 때
2. 자식 프로세스에게 할당된 작업이 더 이상 필요하지 않을 때
3. 부모 프로세스가 종료(exit)되는 경우

### exec() 시스템 콜

프로세스가 지금까지 수행했던 상태를 잊어버리고 그 주소 공간을 완전히 새로운 프로그램으로 덮어씌운 후 새로운 프로그램의 첫 부분부터 다시 실행을 시작하도록 하는 시스템 콜이다.

# 프로세스 간의 협력

---

프로세스는 각자 자신만의 독립적인 주소 공간을 가지고 수행되며 프로세스가 다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.

- 하나의 프로세스는 다른 프로세스의 수행에 영향을 미칠 수 없다.
- 다른 프로세스와 정보를 주고받을 수 있는 방법이 없다.

이런 프로세스의 협력을 위해 운영체제는 협력 메커니즘을 제공한다.

## IPC(Inter-Process Communication)

하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신을 말한다.

이러한 통신에서는 의사소통 기능과 함께 동기화를 보장해주어야 한다.

⇒ 공유 데이터를 서로 다른 두 프로세스가 사용 할 수 있다고 하면 데이터의 불일치 문제가 발생할 수 있기 때문이다.

- IPC는 프로세스들 간의 통신(communication)과 동기화를 이루기 위한 메커니즘을 의미한다.

IPC의 대표적인 방법으로는 메시지 전달(message passing) 방식과 공유 메모리(shared memory) 방식이 있다.

### 메시지 전달 방식(message passing)

- 프로세스 간에 공유 데이터를 일체 사용하지 않고 메시지를 주고받으면서 통신하는 방식
- 두 프로세스의 주소 공간이 다르므로 메시지 전달을 직접 할 수는 없으며 커널이 그 역할을 하게 된다.
    - 메시지 통신을 하는 시스템은 커널에 의해 send(message)와  receive(message)라는 두 가지 연산을 제공받게 된다.
- 원하지 않는 메시지를 전달하면 악영향을 미칠 수 있기 때문에 운영체제는 메시지를 주고 받는 연산을 특권명령으로 규정해 **커널**을 통해서만 가능하도록 하고 있다.

## 간접 통신과 직접 통신

### 직접통신

- 통신하려는 프로세스의 이름을 명시적으로 표시한다.
- 링크는 자동적으로 생성되고, 하나의 링크는 정확히 한 쌍의 프로세스에게 할당된다.
- 각 쌍의 프로세스에게는 오직 하나의 링크만이 존재한다.
- 링크는 단방향성(undirectional)일 수 있으나 대부분의 경우 양방향성(bidirectional)이다.

### 간접통신

- 메시지를 메일박스(mail box) 또는 포트(port)로부터 전달 받는다.
- 각 메일박스에는 고유의 ID가 있으며 메일박스를 공유하는 프로세스들만 서로 통신을 할 수 있다.
- 간접 통신에서 사용되는 커뮤니케이션 링크는 프로세스 간에 메일박스를 공유하는 경우에만 생성된다.
- 하나의 링크가 여러 프로세스들에게 할당될 수 있다.
- 링크는 단방향성 또는 양방향성일 수 있다.

## 공유 메모리(shared memory)

프로세스들이 주소 공간의 일부를 공유한다.

- 운영체제는 공유메모리를 사용하는 시스템 콜을 지원한다.
- 서로 다른 프로세스들이 그들의 주소 공간 중 일부를 공유할 수 있도록 한다.
- 공유 메모리 방식은 프로세스간의 통신을 수월하게 만드는 인터페이스를 제공하지만 서로의 데이터에 일관성 문제가 유발될 수 있다.