# 🔗 참고자료

---

- 기계인간 John Grib - 프록시 패턴(Proxy Pattern) ⇒ [**링크**](https://johngrib.github.io/wiki/pattern/proxy/)
- refactoring guru - 프록시 패턴 ⇒ [**링크**](https://refactoring.guru/ko/design-patterns/proxy)

# ✏공부 내용 정리

---

## ❓프록시 객체 패턴이란?

다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둡니다.

![structure-indexed.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ac42134-2f60-4ad6-a8db-c64e39bc5a92/structure-indexed.png)

1. 서비스 인터페이스는 서비스의 인터페이스를 선언합니다. 프록시가 서비스 객체로 위장할 수 있으려면 이 인터페이스를 따라야 합니다.
2. 서비스는 어떤 유용한 비즈니스 로직을 제공하는 클래스입니다.
3. 프록시 클래스에는 서비스 객체를 가리키는 참조 필드가 있습니다. 프록시가 요청의 처리
   (예 : 초기화 지연, 로깅, 액세스 제어, 캐싱 등)를 완료하면, 그 후 처리된 요청을 서비스 객체에 전달합니다.)
4. 클라이언트는 같은 인터페이스를 통해 서비스들 및 프록시들과 함께 작동해야 합니다.
   그러면 서비스 객체를 기대하는 모든 코드에 프록시를 전달할 수 있기 때문입니다.

ServiceInterface 구현체(Proxy)로 operation() 함수를 호출할 때 Service를 참조하고 있는 Proxy가 realService를 대리하는 구조

## 장단점

**장점**

- 클라이언트들이 알지 못하는 상태에서 서비스 객체를 제어할 수 있습니다.
- 클라이언트들이 신경 쓰지 않을 때 서비스 객체의 수명 주기를 관리할 수 있습니다.
- 프록시는 서비스 객체가 준비되지 않았거나 사용할 수 없는 경우에도 작동합니다.
- 개방/폐쇄 원칙(OCP) 서비스나 클라이언트들을 변경하지 않고도 새 프록시들을 도입할 수 있습니다.
* 개방 폐쇄의 원칙 : 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙 ⇒ [**참고 링크**](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-OCP-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99)

**단점**

- 새로운 클래스들을 많이 도입해야 하므로 코드가 복잡해질 수 있습니다.
- 서비스의 응답이 늦어질 수 있습니다.

## 적용 사례

요청들의 로깅(로깅 프록시) 서비스 객체에 대한 요청들의 기록을 유지하려는 경우

- 프록시는 각 요청을 서비스에 전달하기 전에 로깅(기록) 할 수 있습니다.

요청 결과들의 캐싱(캐싱 프록시). 이것은 클라이언트 요청들의 결과들을 캐시하고 이 캐시들의 수명 주기를 관리해야 할 때, 특히 결과들이 상당히 큰 경우에 사용됩니다.

- 프록시는 항상 같은 결과를 생성하는 반복 요청들에 대해 캐싱을 구현할 수 있습니다.
- 프록시는 요청들의 매개변수들을 캐시 키들로 사용할 수 있습니다.

# 공부하면서 느낀 점

---

- 공부를 하면서 다른 패턴과의 연계되는 내용을 공부해야 한다고 느꼈다.
- 단순히 Proxy의 개념을 이해했다고 끝내지 말고 해당 패턴을 실제로 사용하고 있는 것들을 살펴보자.