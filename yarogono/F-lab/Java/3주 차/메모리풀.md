# 🔗 참고자료

---

- 메모리풀 ⇒ [링크](https://velog.io/@sweet_sumin/%EB%A9%94%EB%AA%A8%EB%A6%AC%ED%92%80)
- 메모리 풀(Memory Pool) 1편 ⇒ [링크](https://blog.naver.com/PostView.naver?blogId=ruvendix&logNo=221333044853)

# ✏공부 내용 정리

---

## ❓메모리 풀이란?

---

필요한 메모리 공간을 필요한 크기, 개수 만큼 사용자가 직접 지정하여 미리 할당 받아 놓고 필요할 때마다 반납하는 기법을 말한다.

## 메모리 풀을 사용하는 이유

---

![KakaoTalk_20150317_214533234.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41a4bb19-1763-4f32-a783-819899fbe14b/KakaoTalk_20150317_214533234.gif)

## malloc()과 new 남용의 문제

위 사진을 보면 알 수 있듯이, 메모리 할당의 남용으로 인해서 그 사이의 공백과 할당된 메모리의 잉여 부분이 생기는 것이다.

이를 메모리 내부, 외부 단편화라고 한다.

단편화는 “작은 조각들이 생기는 현상’ 이라는 뜻이다.

- 내부 단편화 : 할당한 메모리 내부에 잉여 부분이 있는 것.
- 외부 단편화 : 메모리 할당을 남용해서 Job A 와 C의 사이에 사용하기 애매한 공간이 생기는 것.

![YINBipo.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e596bdd-518c-4f5f-b580-ab9a3e5b5209/YINBipo.png)

### 잦은 시스템 콜으로 인한 성능 저하를 줄여준다.

malloc()이나 new을 사용할 때마다 시스템 콜(System Call)이 발생하게 된다.

애플리케이션은 시스템 함수를 직접 호출할 수 없으므로 커널 호출을 통해 메모리를 할당하게 된다.

그러면 이 과정에서 컨텍스트 스위치(Context Switch)로 인해 오버헤드(Overhead)가 발생하게 된다.

이런 잦은 컨텍스트 스위치는 성능을 저하시키는 원인이 된다.

그래서 메모리 영역을 계속 들고 있다가 필요할 때 사용하는 방식이 메모리 풀이다.

# 공부하면서 느낀 점

---

- 공부를 하면서 new 연산자에 대한 내용이 나왔다.
  그렇다면 자바에서 Heap 메모리 영역도 new 연산자 남용 시 생기는 문제도 동일 할 것 같다.
- CS 지식을 좀 더 공부했으면 이해가 훨씬 쉬웠을 것 같다.